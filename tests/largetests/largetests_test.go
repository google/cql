// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package largetests_test

import (
	"context"
	"embed"
	"encoding/json"
	"errors"
	"io/fs"
	"path"
	"runtime"
	"strings"
	"testing"
	"time"

	"github.com/google/cql"
	"github.com/google/cql/result"
	"github.com/google/cql/retriever/local"
	"github.com/google/cql/terminology"
	"github.com/google/go-cmp/cmp"
)

// valuesetDir is the directory containing all the valuesets across all tests.
var valuesetDir = "valuesets"

//go:embed tests valuesets
var testdata embed.FS

var defaultEvalTimestamp = time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)

// TestConfig represents a test configuration for a single end-to-end test. TestConfigs can be
// generated by arbitrary logic as well in the future.
type TestConfig struct {
	// Name of the test.
	Name string
	// Description is an optional longer text description of the test.
	Description string
	// TODO(b/319503337): support multiple CQL file input.
	// CQLFile is the path to the input CQL file.
	CQLFile string
	// BundleFile is the path to the input bundle file.
	BundleFile string
	// WantFile is the path to the expected output file.
	WantFile string
}

func buildAllTestCases() []TestConfig {
	// Future cases can be generated with helpers if needed.
	return []TestConfig{
		// Register new test cases here:
		{
			Name:       "example - Most recent systolic bp with a valid status",
			CQLFile:    "tests/example/main.cql",
			BundleFile: "tests/example/data.json",
			WantFile:   "tests/example/output.json",
		},
		{
			Name:        "CoronaryHeartDiseaseMeasure - Patient in Numerator and Denominator",
			Description: "Patient is above 80 years old, has coronary heart disease, most recent blood pressure is below 150",
			CQLFile:     "tests/CoronaryHeartDiseaseMeasure/main.cql",
			BundleFile:  "tests/CoronaryHeartDiseaseMeasure/included_patient/data.json",
			WantFile:    "tests/CoronaryHeartDiseaseMeasure/included_patient/output.json",
		},
		{
			Name:        "CoronaryHeartDiseaseMeasure - Patient not in Numerator or Denominator, due to coronary heart disease after start of measurement period",
			Description: "Patient is above 80 years old, has coronary heart disease but _after_ start of measurement period, most recent blood pressure is below 150",
			CQLFile:     "tests/CoronaryHeartDiseaseMeasure/main.cql",
			BundleFile:  "tests/CoronaryHeartDiseaseMeasure/patient_not_in_numerator_or_denominator/data.json",
			WantFile:    "tests/CoronaryHeartDiseaseMeasure/patient_not_in_numerator_or_denominator/output.json",
		},
	}
}

func TestLarge(t *testing.T) {
	for _, test := range buildAllTestCases() {
		t.Run(test.Name, func(t *testing.T) {
			cqlFileData, err := testdata.ReadFile(test.CQLFile)
			if err != nil {
				t.Fatalf("Failed to read cql file: %v", err)
			}
			fhirHelpers, err := cql.FHIRHelpersLib("4.0.1")
			if err != nil {
				t.Fatal("FHIRHelpersLib returned error: ", err)
			}
			fhirDM, err := cql.FHIRDataModel("4.0.1")
			if err != nil {
				t.Fatal("FHIRDataModel returned error: ", err)
			}

			bundleFileData, err := testdata.ReadFile(test.BundleFile)
			if err != nil {
				t.Fatalf("Failed to read bundle file: %v", err)
			}
			retriever, err := local.NewRetrieverFromR4Bundle(bundleFileData)
			if err != nil {
				t.Fatalf("Failed to create retriever: %v", err)
			}
			terminology := getTerminologyProvider(t, valuesetDir)

			elm, err := cql.Parse(context.Background(), []string{string(fhirHelpers), string(cqlFileData)}, cql.ParseConfig{DataModels: [][]byte{fhirDM}})
			if err != nil {
				t.Fatalf("Failed to create engine: %v", err)
			}

			results, err := elm.Eval(context.Background(), retriever, cql.EvalConfig{Terminology: terminology, EvaluationTimestamp: defaultEvalTimestamp})
			if err != nil {
				t.Errorf("Failed to run engine: %v", err)
			}

			jsonResults, err := json.MarshalIndent(results, "", "  ")
			if err != nil {
				t.Errorf("Failed to marshal results: %v", err)
			}

			// Diff results
			outputFileData, err := testdata.ReadFile(test.WantFile)
			if errors.Is(err, fs.ErrNotExist) {
				// First time running this test. We're going to fail the test and print the current
				// output to the test log.
				t.Errorf("Test %s failed.\nTest Description: %s\n", test.Name, test.Description)
				t.Errorf("The output file %s doesn't exist. Here are the current output contents to copy and paste:\n", test.WantFile)
				t.Errorf("Got results:")
				t.Errorf("\n%s", jsonResults)
				t.FailNow()
			}
			if err != nil {
				t.Errorf("Failed to read existing output file: %v", err)
			}

			for _, l := range results {
				for exp, expVal := range l {
					if exp == "Fecal Occult Blood Test Performed" {
						t.Logf("Expression: %v", exp)
						t.Logf("Value: %v", expVal)
						lval, _ := result.ToSlice(expVal)
						t.Logf("List Val: %v", lval)
					}
				}
			}

			gotData := string(outputFileData)
			if runtime.GOOS == "windows" {
				// A '\r' is added when parsing on windows, removing.
				gotData = strings.ReplaceAll(gotData, "\r\n", "\n")
			}
			if diff := cmp.Diff(gotData, string(jsonResults)); diff != "" {
				t.Errorf("Test %s failed.\nTest Description: %s\n", test.Name, test.Description)
				t.Errorf("For %s: Diff found in output file (%s) (-want +got). After the diff, the entire got file is pasted for easy copying and pasting:\n%s", test.Name, test.WantFile, diff)
				t.Errorf("Got file:")
				t.Errorf("%s", jsonResults)
			}
		})
	}
}

// forceBenchResult ensures the results are used so the compiler does not optimize away the
// EvalLibraries function.
var forceBenchResult result.Libraries

func BenchmarkInterpreter(b *testing.B) {
	for _, test := range buildAllTestCases() {
		cqlFileData, err := testdata.ReadFile(test.CQLFile)
		if err != nil {
			b.Fatalf("Failed to read cql file: %v", err)
		}
		fhirHelpers, err := cql.FHIRHelpersLib("4.0.1")
		if err != nil {
			b.Fatal("FHIRHelpersLib returned error: ", err)
		}
		fhirDM, err := cql.FHIRDataModel("4.0.1")
		if err != nil {
			b.Fatal("FHIRDataModel returned error: ", err)
		}

		bundleFileData, err := testdata.ReadFile(test.BundleFile)
		if err != nil {
			b.Fatalf("Failed to read bundle file: %v", err)
		}
		retriever, err := local.NewRetrieverFromR4Bundle(bundleFileData)
		if err != nil {
			b.Fatalf("Failed to create retriever: %v", err)
		}
		terminology := getTerminologyProvider(b, valuesetDir)

		elm, err := cql.Parse(context.Background(), []string{string(fhirHelpers), string(cqlFileData)}, cql.ParseConfig{DataModels: [][]byte{fhirDM}})
		if err != nil {
			b.Fatalf("Failed to create engine: %v", err)
		}

		b.Run(test.Name, func(b *testing.B) {
			var force result.Libraries
			for n := 0; n < b.N; n++ {
				force, err = elm.Eval(context.Background(), retriever, cql.EvalConfig{Terminology: terminology, EvaluationTimestamp: defaultEvalTimestamp})
				if err != nil {
					b.Fatalf("Failed to run engine: %v", err)
				}
			}
			forceBenchResult = force
			b.ReportAllocs()
		})
	}
}

func getTerminologyProvider(t testing.TB, dir string) terminology.Provider {
	t.Helper()
	entries, err := testdata.ReadDir(dir)
	if err != nil {
		t.Fatalf("Failed to read valueset directory: %v", err)
	}

	var valuesets = make([]string, 0, len(entries))
	for _, entry := range entries {
		eData, err := testdata.ReadFile(path.Join(dir, entry.Name()))
		if err != nil {
			t.Fatalf("Failed to read valueset file: %v", err)
		}
		valuesets = append(valuesets, string(eData))
	}
	tp, err := terminology.NewInMemoryFHIRProvider(valuesets)
	if err != nil {
		t.Fatalf("Failed to create terminology provider: %v", err)
	}
	return tp
}
